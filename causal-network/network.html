<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Network Model</title>
<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->

<!-- <script src="https://d3js.org/d3.v3.min.js"></script> -->
<script src="./js/d3.v3.min.js"></script>

<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.0.3/math.js"></script> -->
<script type="text/javascript" src="./js/math.js"></script>

<style type="text/css">

body {
  font-family: serif;
  font-size: 16px;
}

.link {
  fill: none;
  stroke: #6c6c6c;  /*#6c6c6c*/
  stroke-width: 0.5px; /*1.5px;*/
}

/*#licensing {
  fill: green;
}

.link.licensing {
  stroke: green;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}*/


circle {
  fill: #ddd;  /*#ccc; ddd*/
  stroke: #333;
  stroke-width: 1px;
  cursor: pointer;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  /*text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;*/
}

table {
  /*float:left;*/
  position:absolute;
  /*display:inline;*/
  margin:10px;
  text-align:center;
}

#end {
  stroke-width: 5px;
}

#holder {
  /*border: 1px solid #aaa;*/
}

#score {
  display:inline-block;
  position:absolute;
}

#wrapper {
  text-align:center;
  margin:auto;
}


#reset {
  /*text-align:center;*/
/*  margin-left:auto;
  margin-right:auto;*/
  /*margin: 0 auto;*/
/*  display:inline-block;*/
  position:absolute;
  bottom:0;
  display:inline-block;
  margin:auto;
}


</style>
</head>

<body>


<!-- <div id='wrapper'>
  <div id="score">
    <table>
      <tbody>
        <tr>
          <th> Direct Impact: </th>
          <td id="direct">0.00</td>
        </tr>
        <tr>
          <th> Indirect Impact: </th>
          <td id="indirect">0.00</td>
        </tr>
        <tr>
          <th> Total Impact: </th>
          <td id="total">0.00</td>
        </tr>
      </tbody>
    </table>
  (click to reset)
  </div>
</div> -->

<table>
  <tbody>
    <tr>
      <th> <u>Impacts</u> </th>
      <!-- <td id="elements">(click to reset)</td> -->
    </tr>
    <tr>
      <th> Direct: </th>
      <td id="direct">0.00</td>
    </tr>
    <tr>
      <th> Indirect: </th>
      <td id="indirect">0.00</td>
    </tr>
    <tr>
      <th> Total: </th>
      <td id="total">0.00</td>
    </tr>
  </tbody>
</table>
<!-- <button id='reset'>Reset</button> -->

<div id='wrapper'>
<div id='reset'>
<p>(click to reset)</p>
</div>
</div>

<div id="holder">
</div>


<script type="text/javascript">

//Source: http://jsfiddle.net/bswv1mqe/6/
// https://stackoverflow.com/questions/27785505

// Best: Networks for Thinking About the World
// Best: Network Models for Thinking About the World
//An alternate mental model, network style
//A network model for thinking about the world
//A network model of the world -- not really a world model, more of an EA one.  
//Causal Network Models and Thinking about the world.  

//Writing: 
//While my previous post saw the world as a set of detached causes that could absorb money, 
//this one views it as more of a network.  Thinking of the world as a network is especially
//important when you expect the largest impacts of your actions to be indirect, or you're considering
//some type of upstream intervention like "Increasing the rate of economic growth", or 
//"strengthening healthcare systems", or "improving educational outcomes", or 
//"campaigning for a politician".  

//The further your intervention is from the final effect, the more the context, and mediating steps
//matter.  
//"Causality in complex interventions", Dean Rickles

//For demonstration purposes, have the cell with the smallest direct effect
//have the largest indirect one.  

// You have one click.  The direct impact of your click is proportional to the size of
// the circle.  But the circles are also connected to a network, with the secondary effects
// proportional to the size of the edges connecting the circles (to see the edge direction, hover over
// a circle). This is called a cyclic graph, so there can also be looping feedback between circles, 
// which eventually decays.

// Show vis here  

// It may seem like selecting circle D is the best approach to start because of it's large direct
// effect, but circles B and E outperform it because of their connections to the network. 
// Even though circle E has the smallest direct impact of 1, it has larger, diffuse effect on others.  
// So the point is that if you're working in a complex system, pay close attention to potential 
// indirect effects of your actions because they might be more important.  

// I chose some values for the network to demonstrate a point.   

// How it works
// Go over the math from the EA post, give credit to them.  
// Math is stolen from this post: http://effective-altruism.com/ea/1h9/test/

// Also show the matrix 

//Each row in this matrix represents the outgoing
//impact from a node on the others.  So for row a, 
//a 1 unit increase in a causes a 0.1 increase in e.  
//So if a is 5, e is 5*0.1 = 0.5, then the outgoing 
//impacts from e are calculated, which is 0.5*1.5 = 0.75 for
//a, b, c, d. These then propagate out.  Some of it returns to a ()
//and cycles out again (e.g. a->e = 0.75*0.1 = 0.075 again). 
//This infinite loop has a mathematical solution: 
//impact_vector*(I-M)^-1 is the total sum.
// As long as the feedback loop decays over time: 
// http://effective-altruism.com/ea/1h9/test/
// If they both have a feedback of > 1, it will continue indefinitely. 

// So if there is a loop anywhere, as long as the amount that returns
// to the starting point is lower than it was initially, it's not
// infinite.  I'm sure there's something hand-wavey here I could say about
// entropy closed in thermodynamic systems . . .  

//Conclusion

//I'm not interested in using models like this to actually make concrete predictions. 
//Instead, I just want to communicate general ideas to be aware of when making decisions about 
//prioritization.  Providing different mental models to switch between depending on the context.


//http://effective-altruism.com/ea/1h6/causal_networks_model_i_introduction_user_guide/
//The model does not explicitly model time passing. Instead it takes as inputs increases of funding for different EA cause areas in 2017, calculates various intermediary effects (including simply modelled feedback loops) and then outputs effects in 2050. We chose 2050 as the end point because of the difficulty of extrapolating estimates much further into the future. The model is therefore not very useful for considering most long-term future effects, although it does output the probability of global catastrophic risks and existential risks occurring before 2050.

//The ethical theories considered are also constrained, with outputs only being sufficient to make crude short-term total utilitarian calculations (which are explained in section 6), estimate QALYs saved as an approximation of value according to some forms of person-affecting views, and set out existential and global catastrophic risk in the time frame considered (2017-2050).

//There are also more general arguments to be made against taking cost-effectiveness estimates too literally, as laid out in this classic GiveWell post, which you might want to keep in mind.

//The Changes In Funding section (in green) contains the modelâ€™s inputs, allowing you to compare how funding different causes has different effects. Note the final model is linear in respect to these inputs, so funding by 10 million will not produce any interesting effects not seen by funding it by 1 million. In the real world these elasticity and differential functions have diminishing returns: for instance, increasing funding by 100% often will not change outputs by 100 times as much as increasing funding by 1%. Keep this in mind if you use large numbers as inputs.


//TODO: potentially implement a breadth first search that highlights all child branches
// beyond immediate one
//TODO: Add possible negative effects.  Will that work with current matrix multiplication?
// would also be interesting if you had one with negative direct effects, but large positive
// indirect effects. 
//TODO: maybe differentially color incoming and outgoing connections?
//TODO: Are you thinking about direct effects correctly?  In their model, the starting point
//is spending some money on a node and the effects are what cascade from that.  So in the case
//of your vis, the direct effects would be effects on the direct connections, not the value of the node. 
//So maybe ditch the node size, and just have a click equal to spending your money on that node? And skip
//the direct and indirect effects, and just show the total? And on the click, the "direct" effect of a node
//is the sum of all it's outgoing links (it's value in the matrix, including feedbacks? or w/o?  w/o, you'd
//have to sum the result of the first matrix multiplication.) Direct = vector*Matrix, once.  
//This would also solve your negative value problem, as you'd always be spending +money, It's just the
//cascading effects that would be negative. This assumes symmetry I guess.  
//This way, if you choose to spend money on what's an outcome measure without any outgoing links, 
//you won't have any effect. 
// For color on the EA network one, just color it blue if it was harmed, red if improved (binary), and then
// show total score.  
//TODO: for the ea-network one, only have the green changeable things from the UI be clickable.  Also, you can't
// have a total output, just a list of total outcomes (the purple box).  
// But in that purple box, they do have total sums, for humans and animals, maybe just report those. 
//TODO: embed in the value whether a positive is good, or bad, But coloring based on values in general
// isn't helpful here because of massive differences in numerical effect/ units. Normalize somehow?  
//TODO: also, on the actual large network one, add tooltips that explain what the area is.  E.g. global
//governance.  
//TODO: Why are some monetary donations differentials, and some elasticities, yet all the units are $mil
//TODO: Solve first 100 iterations of the matrix multiplication (or as many as possible), then animate the spread
// across the network.  

// Ok, for the EA version, use their gray, green, red, blue color scheme, then make green ones
// clickable, show intermediate values on a click (maybe color on if it increased or decresed), 
// then increase size of output nodes (or change color?), along with value, and Total.  

//NOTE: The final value, node, 42, already calculates the total expected impact:
//Expected Cumulative change in QALYs (2050)


//Globals
//var order = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
var order = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
//var impacts = [3, 4, 1, 6, 3, 2, 1]
var impacts = [3, 4, 2, 6, 1, 2, 2]
//var impacts = [1, 1, 1, 1, 1, 1, 1]  //Every one now has same impact, it's direct effect is via it's connections
// var lookup = {};
// for (var i = 0; i< order.length; i++) {
//   lookup[order[i]] = impacts[i];
// }

//all rows of matrix, with column/row headers of order
// Maybe, have the diagonal be the impacts of the click, then 
// just ignore the diagonal when building the links
// var matrix = [
//   [0, 3, 5, 0, 1],
//   [0, 0, 0, 6, 0],
//   [5, 0, 0, 2, 0],
//   [0, 0, 3, 0, 0],
//   [1, 2, 0, 0, 0]
// ]
// var matrix = [
//   [0, 0, 0, 0, 1],
//   [0, 0, 0, 6, 0],
//   [0, 0, 0, 2, 0],
//   [0, 0, 3, 0, 0],
//   [0, 0, 2, 0, 0]
// ]
//I guess fractions are what's needed?
// var matrix = [
// //  a,   b,   c,   d,   e,   f,   g
//   [0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0], //a
//   [0.0, 0.0, 0.0, 0.6, 0.0, 0.2, 0.0], //b
//   [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0], //c
//   [0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0], //d
//   [0.2, 0.3, 0.2, 0.5, 0.0, 0.0, 0.0], //e
//   [0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0], //f
//   [0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0]  //g
// ]
//Each row in this matrix represents the outgoing
//impact from a node on the others.  So for row a, 
//a 1 unit increase in a causes a 0.1 increase in e.  
//So if a is 5, e is 5*0.1 = 0.5, then the outgoing 
//impacts from e are calculated, which is 0.5*1.5 = 0.75 for
//a, b, c, d. These then propagate out.  Some of it returns to a ()
//and cycles out again (e.g. a->e = 0.75*0.1 = 0.075 again). 
//This infinite loop has a mathematical solution: 
//impact_vector*(I-M)^-1 is the total sum.
// As long as the feedback loop decays over time: 
// http://effective-altruism.com/ea/1h9/test/
// If they both have a feedback of > 1, it will continue indefinitely.  

//[2] Subject to the some conditions, which in our case are equivalent to requiring feedback 
//loops (such as the one above) to decay over time instead of growing larger.
var matrix = [
//  a,   b,   c,   d,   e,   f,   g
  [0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0], //a
  [0.0, 0.0, 0.0, 0.6, 0.0, 0.2, 0.0], //b
  [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0], //c
  [0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0], //d
  [1.5, 1.5, 1.5, 1.5, 0.0, 0.0, 0.0], //e
  [0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0], //f
  [0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0]  //g
]

// var order = ['a', 'b', 'c']
// var impacts = [1800,0,0]
// var matrix = [[0,1/3,0],[0,0,1/600],[0,0,0]];


//Then build the links list from the matrix by iterating
//over the rows and columns of the matrix:
var links = [];
//var points = [];
for (var i=0; i<matrix.length; i++) {
  for (var j=0; j<matrix[i].length; j++) {
    // if (i === j) {
    //   //Don't connect circles to themselves,
    //   //diagonal is their individual impacts
    //   //continue;
    //   //It's a node:
    //   // var point = {index:order[i], impact:matrix[i][j]};
    //   // points.push(point);
    //   continue;  //Don't execute rest of logic
    // } else if (matrix[i][j] !== 0) {
    //   var edge = {source: order[i], target: order[j], impact: matrix[i][j]}
    //   links.push(edge);
    // }
    if (matrix[i][j] !== 0) {
      var edge = {source: order[i], target: order[j], impact: matrix[i][j]}
      links.push(edge);
    }
  }
}


var points = {};
//https://stackoverflow.com/questions/17181421/uncaught-typeerror-cannot-call-method-push-of-undefined-d3-force-layout#17186156

// Compute the distinct nodes from the links.
links.forEach(function(link) {
  link.source = points[link.source] || (points[link.source] = {name: link.source});
  link.target = points[link.target] || (points[link.target] = {name: link.target});
  // link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
  // link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
});

//Add the impacts to the points:
for (var i=0; i<impacts.length; i++) {
  points[order[i]].impact = impacts[i];
}

// points.forEach(function(point) {
//   points[point.name].impact = lookup[point.name]; 
// })

// var width = 960,
//   height = 800;

// var width = 700,
//   height = 450;
var width = 0.9*window.innerWidth,
  height = 0.9*window.innerHeight;


var results = false;  
var click = false;


/////End Globals



var force = d3.layout.force()
    //.nodes(d3.values(nodes))
    .nodes(d3.values(points))
    //.nodes(points)
    .links(links)
    .size([width, height])
    .linkDistance(90) //60
    .charge(-1500)  //-300  -1500
    .on("tick", tick)
    .start();

// force.start();
//for (var i = 0; i < impacts.length; ++i) force.tick();
//force.stop();

//var svg = d3.select("body").append("svg")
var svg = d3.select("#holder").append("svg")
    .attr("width", width)
    .attr("height", height);

// var color = d3.scale.linear()
//     //.domain(d3.extent(links, function(d) {return d.impact}))
//     .domain(d3.extent(impacts))
//     .range(["white", "green"]);

var colorScale = d3.scale.linear()
    //.domain(d3.extent(links, function(d) {return d.impact}))
    .domain(d3.extent(impacts))
    .range(["white", "green"]);

var circleScale = d3.scale.linear()
    //.domain(d3.extent(links, function(d) {return d.impact}))
    .domain(d3.extent(impacts))
    .range([18, 40]);

var arcScale = d3.scale.linear()
    .domain(d3.extent(links, function(d) {return d.impact}))
    .range([1, 2]);

// Per-type markers, as they don't inherit styles.
// https://stackoverflow.com/questions/28050434/introducing-arrowdirected-in-force-directed-graph-d3
svg.append("defs").selectAll("marker")
    //.data(["suit", "licensing", "resolved"])
    .data(["end"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)  //-1.5
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

var path = svg.append("g").selectAll("path")
    .data(force.links())
  .enter().append("path")
    .attr("class", "link")
    // You could use stroke width and marker from the start:
    // Then just define a linear scale to go form impact > stroke-width in pixels
    .style("stroke-width", function(d) { return arcScale(d.impact); });
    //.attr("marker-end", "url(#end)" ); //function(d) { return "url(#end)"; });
    //.style("stroke-width", 5);
    // Original
    // .attr("class", function(d) { return "link " + d.type; })
    // .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

function reset(){
  click = false; //set global
  results = false;
  path.style('opacity', 1);
  path.style('stroke-dasharray', 0);
  //results = Array(matrix.length).fill(0);
  circles.style('fill', '#eee');
  var ids = ['direct', 'indirect', 'total']; //'elements',
  ids.forEach(function(el) {
    d3.select('#' + el).html("0.00");
  })
};

svg.on('click', reset);

var nodes = svg.selectAll(".node")
    .data(force.nodes())
    .enter()
    .append("g")
    .attr("class","node")
    .call(force.drag);

//var circles = nodes.append("circle")

var circles = nodes.append("circle")
  //.attr("r", function(d){ d.radius = d.name.length*5; return d.radius; }
  //.attr("r", 15)
  .attr("r", function(d){return circleScale(d.impact); });
  //.attr("fill", function(d){return color(d.impact);});



var texts = nodes.append("text")
    .attr("text-anchor", "middle")
    //.attr("transform", "translate(" + d.x + "," + d.y + 10 + ")")
    .text(function(d) {
      return d.name;
    });

// d3.select('#reset').on('click', function(d) {

//   d3.selectAll("text").remove();

//   nodes.append("text")
//       .attr("text-anchor", "middle")
//       //.attr("transform", "translate(" + d.x + "," + d.y + 10 + ")")
//       .text(function(d) {
//         return d.name;
//       });

//   var ids = ['direct', 'indirect', 'total']; //'elements',
//   ids.forEach(function(el) {
//     d3.select('#' + el).html("");
//   });

//   circles.style('fill', '#ddd');

// })
 

// Use elliptical arc path segments to doubly-encode directionality.
nodes.on('mouseover', function(d) {
  // path.style('stroke-width', function(l) {
  //   if (d === l.source)  //d === l.source || d === l.target
  //     //return 4;
  //     return l.impact;
  //   else
  //     return 0.5;
  //   });

  //TODO: maybe differentially color incoming and outgoing connections?

  if (click === false) {
    path.style('opacity', function(l) {
      //console.log(d);
      //console.log(l);
      if (d === l.source || d === l.target)  //d === l.source || d === l.target
        return 1;
      else
        return 0.2;  //0.15
      });

    //http://www.d3noob.org/2013/01/making-dashed-line-in-d3js.html
    path.style('stroke-dasharray', function(l) {
      //console.log(d);
      //console.log(l);
      if (d === l.target)  //d === l.source || d === l.target
        return "3, 3";
      else
        return 0;  //0.15
      });
  };

});

nodes.on('mouseout', function(d) {
  //path.style('stroke-width', 0.5);
  //path.style('stroke-width', function(d){return d.impact;});
  if (click == false) {
    path.style('opacity', 1);
    path.style('stroke-dasharray', 0);
  }
});

nodes.on('click', function(d) {

  //reset();
  //Reset path styles
  path.style('opacity', 0.45);
  path.style('stroke-dasharray', 0);

  click = true;

  //var el = d3.select(this);
  var len = impacts.length; 
  var loc = order.indexOf(d.name);

  //Build the array to multiply
  // var arr = math.zeros(len);
  // math.subset(arr, math.index(0, loc), impacts[loc]); //Set value
  var arr = Array(impacts.length).fill(0); //[];
  arr[loc] = impacts[loc];
  // for (var i=0; i<len; i++) {
  //   if (i === loc) { arr[i] = impacts[loc]; } 
  //   else { arr[i] = 0; }
  // }


  var res = solve(arr, matrix);
  // console.log(res);
  // console.log(arr);
  //Then use this array to color elements, both nodes and lines inbetween.  
  //Actually, how will this work?  I guess the matrix will just refer to nodes, 
  //so just those will be colored?  


  updateScores(d.name, arr, res);


  //Create color scale unique to this solution.  Can't think of how to make 
  //one global to all solutions.  Something to think about.  
  // var resScale = d3.scale.linear()
  //   .domain(d3.extent(Object.values(res)))
  //   .range(["white", "red"]);
  // var resScale = d3.scale.linear()
  //   .domain([-5,0, 10])
  //   .range(["yellow","white", "red"]);
  var resScale = d3.scale.linear()
    .domain([-10, 0, 10])
    .range(["blue", "#eee", "red"]);   //"red"

  // d3.selectAll('circle')
  //   .attr('fill', function(d) {return lookup[d.parentNode.name];});

  nodes.each(function(d) {
    var val = res[d.name];

    d3.select(this)
      .selectAll("circle")
      .transition()
      .duration(750)
      .style('fill', function(){ 
        return resScale(val); 
      });
  })

  d3.event.stopPropagation();

});


function updateScores(name, arr, res) {
  //https://stackoverflow.com/questions/1230233/how-to-find-the-sum-of-an-array-of-numbers#16751601
  var direct = arr.reduce((a, b) => a + b, 0);
  
  //var direct = math.multiply(arr, matrix);  //Calculate first step, direct effect on neighbors
  //console.log(direct);  
  //But you still need to incorporate the effect of actually acting on the node.  
  //This is a direct effect as well. . . 
  //Maybe leave this one the same, then the EA network one will have the click spending
  //1 million or something. 
  //Because in the other one, the money you spend will be converted to impact on the last step, 
  //so that could be your direct impact.  sum(Money_Array * Impact_array)
  //Technically, you should be able to do this for all of the circles even in the ea-network one, 
  //by multiplying whatever array eventually converts the cell value to impact.  

  //direct = direct.reduce((a, b) => a + b, 0); //Sum that array. 

  var total = Object.values(res).reduce((a, b) => a + b, 0);
  //var direct = res[name];
  var indirect = total - direct;
  // console.log("Direct: " + direct);
  // console.log("Indirect: " + indirect);
  // console.log("Total: " + (direct +indirect));
  var ks = Object.keys(res);
  var vl = Object.values(res);
  var str = '';
  ks.forEach(function(el,i) {
    str += '&nbsp<b>' + el + ':&nbsp</b>' + Math.round(vl[i]*100)/100;
  });

  var lookup = {
    'direct': direct.toFixed(2), 'indirect': Math.round(indirect*100)/100,
    'total': Math.round(total*100)/100
  }  //, 'elements': str Math.round(direct*100)/100

  var ids = ['direct', 'indirect', 'total']; //'elements',
  ids.forEach(function(el) {
    d3.select('#' + el).html(lookup[el]);
  })

  d3.selectAll("text").remove();

  nodes.append("text")
      .attr("text-anchor", "middle")
      //.attr("transform", "translate(" + d.x + "," + d.y + 10 + ")")  Math.abs(number) < 1e-10
      .text(function(d) {
        return d.name + ': ' + Math.round(res[d.name]*10)/10;
      });

  console.log(res);

  path.style('opacity', function(l) {
    //console.log(d);
    if (Math.abs(res[l.source.name]) > 1e-10)  //Check for near zero numbers //d === l.source || d === l.target
      return 1;
    else
      return 0.05;  //0.15
  });

}

function tick() {
  path.attr("d", linkArc);
  nodes.attr("transform", transform);
}


function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy); //Math.pow((dx * dx + dy * dy), 0.6)
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}


//Ok, this function should work:
//math.multiply([1800,0,0], math.inv(math.subtract([[1,0,0],[0,1,0],[0,0,1]], [[0,1/3,0],[0,0,1/600],[0,0,0]])))
// >> [1800, 600, 1]
// and math.multiply([0,20], math.inv(math.subtract([[1,0],[0,1]], [[0,1],[0.5,0]])))
// >> [20, 40]

function solve(arr, matrix) {
  //Get ordered array of results, return it. 
  //http://mathjs.org/docs/datatypes/matrices.html

  var len = impacts.length;

  //Create inverse matrix
  // var inv = matrix_invert(matrix);
  // var res = multiply(arr, inv);
  var ident = math.identity(len, len);
  //var temp = math.subtract(ident, matrix);
  //var temp = math.inv(math.subtract(ident, matrix));
  var res = math.multiply(arr, math.inv(math.subtract(ident, matrix))).toArray();

  // Map results to circle values
  var lookup = {};
  for (var i = 0; i< res.length; i++) {
    lookup[order[i]] = res[i];
  }
  return lookup; 
}


//TODO: potentially implement a breadth first search that highlights all child branches
// beyond immediate node
//https://stackoverflow.com/questions/5411270/breadth-first-traversal-of-object
function traverse(state) {
    var queue = [],
        next = state;
    while (next) {
        var children = getChildren(next, links);
        if (children) {
            // $.each(next.possibleMoves, function(i, possibleMove) {
            //     queue.push(possibleMove);
            // });
            next.possibleMoves.forEach(function(i, possibleMove) {
                queue.push(possibleMove);
            });
        }
        next = queue.shift();
    }
}

//Itearates through list of links, 
function getChildren(el, ls) {
  var children = [];
  for (var i=0; i<ls.length; i++) {
    if (ls[i].source === el.name) {
      children.push(ls[i]);
    }
  }
  return children;
}



//https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript
function matrix_multiply(m1, m2) {
    var result = [];
    for (var i = 0; i < m1.length; i++) {
        result[i] = [];
        for (var j = 0; j < m2[0].length; j++) {
            var sum = 0;
            for (var k = 0; k < m1[0].length; k++) {
                sum += m1[i][k] * m2[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}

// Returns the inverse of matrix `M`.
// Source: http://blog.acipo.com/matrix-inversion-in-javascript/
function matrix_invert(M){
    // I use Guassian Elimination to calculate the inverse:
    // (1) 'augment' the matrix (left) by the identity (on the right)
    // (2) Turn the matrix on the left into the identity by elemetry row ops
    // (3) The matrix on the right is the inverse (was the identity matrix)
    // There are 3 elemtary row ops: (I combine b and c in my code)
    // (a) Swap 2 rows
    // (b) Multiply a row by a scalar
    // (c) Add 2 rows
    
    //if the matrix isn't square: exit (error)
    if(M.length !== M[0].length){return;}
    
    //create the identity matrix (I), and a copy (C) of the original
    var i=0, ii=0, j=0, dim=M.length, e=0, t=0;
    var I = [], C = [];
    for(i=0; i<dim; i+=1){
        // Create the row
        I[I.length]=[];
        C[C.length]=[];
        for(j=0; j<dim; j+=1){
            
            //if we're on the diagonal, put a 1 (for identity)
            if(i==j){ I[i][j] = 1; }
            else{ I[i][j] = 0; }
            
            // Also, make the copy of the original
            C[i][j] = M[i][j];
        }
    }
    
    // Perform elementary row operations
    for(i=0; i<dim; i+=1){
        // get the element e on the diagonal
        e = C[i][i];
        
        // if we have a 0 on the diagonal (we'll need to swap with a lower row)
        if(e==0){
            //look through every row below the i'th row
            for(ii=i+1; ii<dim; ii+=1){
                //if the ii'th row has a non-0 in the i'th col
                if(C[ii][i] != 0){
                    //it would make the diagonal have a non-0 so swap it
                    for(j=0; j<dim; j++){
                        e = C[i][j];       //temp store i'th row
                        C[i][j] = C[ii][j];//replace i'th row by ii'th
                        C[ii][j] = e;      //repace ii'th by temp
                        e = I[i][j];       //temp store i'th row
                        I[i][j] = I[ii][j];//replace i'th row by ii'th
                        I[ii][j] = e;      //repace ii'th by temp
                    }
                    //don't bother checking other rows since we've swapped
                    break;
                }
            }
            //get the new diagonal
            e = C[i][i];
            //if it's still 0, not invertable (error)
            if(e==0){return}
        }
        
        // Scale this row down by e (so we have a 1 on the diagonal)
        for(j=0; j<dim; j++){
            C[i][j] = C[i][j]/e; //apply to original matrix
            I[i][j] = I[i][j]/e; //apply to identity
        }
        
        for(ii=0; ii<dim; ii++){
            // Only apply to other rows (we want a 1 on the diagonal)
            if(ii==i){continue;}
            
            // We want to change this element to 0
            e = C[ii][i];
            
            for(j=0; j<dim; j++){
                C[ii][j] -= e*C[i][j]; //apply to original matrix
                I[ii][j] -= e*I[i][j]; //apply to identity
            }
        }
    }
    
    //we've done all operations, C should be the identity
    //matrix I should be the inverse:
    return I;
}

</script>


</body>